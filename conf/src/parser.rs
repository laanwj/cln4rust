//! Parser implementation to parse the simple
//! conf syntax for core lightning conf file
use crate::{
    file::{File, SyncFile},
    CLNConf, ParsingError, SyncCLNConf,
};
use albert_stream::{BasicStream, Stream};

pub struct Parser {
    file: File,
    create_if_missing: bool,
}

type Word = String;

impl Parser {
    pub(crate) fn new(file_path: &str, create_if_missing: bool) -> Self {
        Parser {
            file: File::new(file_path),
            create_if_missing,
        }
    }

    fn read_and_split(&self) -> Result<Vec<Word>, ParsingError> {
        let content = if !self.file.exist() && self.create_if_missing {
            self.file.write(
                "# core lightning configuration generated by coffe please do not edit this",
            )?;
            self.file.read()
        } else {
            self.file.read()
        }?;

        let lines: Vec<String> = content
            .split('\n')
            .filter(|it| !it.is_empty())
            .map(|it| it.to_string())
            .collect();
        let mut words = vec![];
        for line in lines {
            if line.starts_with('#') {
                words.push(format!("comment {line}"));
                continue;
            }
            if line.starts_with("include") {
                words.push(line);
                continue;
            }
            let mut split: Vec<String> = line.split('=').map(|it| it.to_owned()).collect();
            let key = split.first().unwrap().to_owned();
            split.remove(0);
            let val = if split.is_empty() {
                "".to_owned()
            } else {
                split.join("=")
            };
            words.append(&mut vec![key, val]);
        }

        Ok(words)
    }

    pub fn parse(&self, conf: &mut CLNConf) -> Result<(), ParsingError> {
        let words = self.read_and_split()?;
        let mut stream = BasicStream::<Word>::new(&words);
        self.parse_stream(&mut stream, conf)
    }

    fn parse_stream(
        &self,
        stream: &mut BasicStream<Word>,
        conf: &mut CLNConf,
    ) -> Result<(), ParsingError> {
        while !stream.is_end() {
            self.parse_key_value(stream, conf)?;
        }
        Ok(())
    }

    fn parse_key_value(
        &self,
        stream: &mut BasicStream<Word>,
        conf: &mut CLNConf,
    ) -> Result<(), ParsingError> {
        let key = stream.advance().to_owned();
        if key.starts_with("comment") {
            let value = key.strip_prefix("comment ").unwrap().trim();
            conf.add_conf(&key, value)?;
            return Ok(());
        }
        if key.starts_with("include") {
            let value = key.strip_prefix("include ").unwrap().trim();
            let mut subconf = CLNConf::new(value.to_owned(), false);
            subconf.parse()?;
            conf.add_subconf(subconf)?;
        } else {
            let value = stream.advance().to_owned();
            conf.add_conf(&key, &value)?;
        }
        Ok(())
    }
}
